Most enterprise applications with significant business and technical complexity are defined by multiple layers. These layers are a logical artifact that help developers manage the complexity in the code. For example, the domain model layer is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like the presentation layer. Additionally, always-valid entities (see the Designing validations in the domain model layer section) are controlled by aggregate roots (root entities). This is why the ViewModel is for presentation layer needs.

When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root. Figure 7-5 shows how a layered design is implemented in the eShopOnContainers application. Each layer is a VS project: Application layer is Ordering.API, Domain layer is Ordering.Domain and Infrastructure layer is Ordering.Infrastructure. It is important to design the system so that each layer communicates only with certain other layers. This approach may The Ordering.Domain layer library has dependencies only on the.NET libraries or NuGet packages, but not on any other custom library.

This layer is responsible for representing concepts of the business, information about the business situation, and business rules. It is coded as a class library with domain entities that capture data plus behavior. Following the Persistence Ignorance and the Infrastructure Ignorance principles, this layer must not take direct dependencies on the infrastructure, which means that domain model entity classes should be POCOs. Even when it is important to follow the Persistence Ignorance principle for your Domain model, it is still important to understand the physical data model and how it maps to your entity object model. There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.

The application layer in.NET is commonly coded as an ASP.NET Core Web API project, which implements the microservice's interaction, remote network access, and external Web APIs used from the UI or client apps. It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down. It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities. The application logic is where you implement all use cases that depend on a given front end. The goal of DDD is to ensure that the domain logic in the domain model layer, its invariants, the data model, and related business rules are completely independent from the presentation and application layers.

The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store. In accordance with the Persistence Ignorance and Infrastructure Ignorance principles, the infrastructure layer must not "contaminate" the domain model layer. The domain model layer class library should have only the domain code, just POCO entity classes implementing the heart of the software and completely decoupled from infrastructure technologies. This layer design should be independent for each microservice, allowing for the most complex microservices to be implemented following DDD patterns while implementing simpler data-driven microservices in a simpler way.



Domain-Driven Design (DDD) is an approach to software development that emphasizes a strong connection between the implementation code and the business domain it represents. When applying DDD principles to microservices architecture, the layers can be organized in different ways depending on the specific implementation. However, there are some common layers that are typically present in DDD-based microservices. These layers include:

Application Layer: The application layer is responsible for coordinating the execution flow between different domain objects/entities. It contains application services that define the use cases or operations that can be performed within the microservice. It orchestrates the interaction between the presentation layer and the domain layer.

Domain Layer: The domain layer represents the heart of the microservice and encapsulates the business logic and rules. It contains domain objects/entities, aggregates, value objects, and domain services. The domain layer focuses on solving business problems and expresses the concepts and behaviors of the business domain.

Infrastructure Layer: The infrastructure layer provides technical capabilities and support for the microservice. It includes components such as data access objects (DAOs), repositories, external service integrations, messaging frameworks, caching mechanisms, and other infrastructure-related implementations. The infrastructure layer interacts with external systems and services to provide persistence, communication, and other necessary infrastructure concerns.

Presentation Layer: The presentation layer handles the interaction with external systems or user interfaces. It can be a web API, a user interface (UI), or any other means through which the microservice exposes its functionality to external clients. The presentation layer translates external requests into actions performed by the application layer and returns appropriate responses.

It's important to note that the organization and naming of these layers can vary depending on the specific architectural choices and the technologies used. The key idea in DDD is to focus on the business domain and create a clear separation of concerns between layers, ensuring that the business logic remains decoupled from infrastructure and presentation concerns.